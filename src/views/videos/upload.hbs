{{#> layouts/main}}

<div class="video-upload-page">
  <!-- Header and Content Selection Flex Container -->
  <div class="upload-main-content">
    <div class="upload-left-panel">
      <div class="upload-header">
        <h1>Monthly Usage</h1>
        <p>Videos imported this month.</p>
        
        {{#if subscription}}
        <div class="usage-status">
          <div class="usage-bar">
            <div class="usage-fill{{#if (gt subscription.usage.videos 0)}} usage-fill-active{{/if}}" style="width: {{subscription.percentages.videos}}%"></div>
          </div>
          <span class="usage-text">
            {{subscription.usage.videos}}/{{subscription.limits.videos}} videos used this month
            {{#if (eq subscription.limits.videos subscription.usage.videos)}}
            <span class="limit-reached">Limit reached - <a href="/subscription/upgrade">Upgrade plan</a></span>
            {{/if}}
          </span>
        </div>
        {{/if}}
      </div>
    </div>

    <div class="upload-right-panel">
      <!-- Content Type Selection -->
      <div class="content-type-selection-container" id="content-type-selection-container">
    <div class="content-selection-header">
      <div class="header-left">
        <h1>Select Content Types to Generate</h1>
        <p>Choose which AI-generated content you want for your videos</p>
      </div>
      <div class="header-center hidden" id="header-selection-info">
        <span id="selected-content-count">0</span> &nbsp;content types selected
      </div>
      <div class="header-right hidden" id="header-selection-controls">
        <button type="button" id="select-all-content-btn" class="btn btn-secondary btn-small">Select All</button>
        <button type="button" id="clear-all-content-btn" class="btn btn-secondary btn-small">Clear All</button>
      </div>
    </div>
    
    <div class="content-types-grid hidden" id="content-types-grid">
      <!-- Content types will be loaded dynamically -->
    </div>
    
        
        <div class="content-type-error hidden" id="content-type-error">
          <div class="error-message">
            Failed to load content types. Please refresh the page and try again.
          </div>
        </div>
      </div>
      <!-- End Content Type Selection Container -->
    </div>
    <!-- End Upload Right Panel -->
  </div>
  <!-- End Upload Main Content -->

  {{#if success}}
  <div class="alert alert-success">{{success}}</div>
  {{/if}}

  {{#if error}}
  <div class="alert alert-error">
    {{#if (eq error "oauth_denied")}}
      YouTube connection was denied. Please try again and grant access to continue.
    {{else if (eq error "oauth_invalid")}}
      Invalid YouTube connection attempt. Please try connecting again.
    {{else if (eq error "oauth_failed")}}
      YouTube connection failed. Please check your internet connection and try again.
    {{else if (eq error "oauth_error")}}
      There was an error connecting to YouTube. Please try again.
    {{else}}
      {{error}}
    {{/if}}
  </div>
  {{/if}}

  <div class="upload-methods-container">
    <!-- YouTube OAuth Method -->
    <div class="upload-method youtube-method">
      <div class="method-header">
        <h1>Import from YouTube</h1>
        <p>Connect your YouTube account to select and import videos</p>
      </div>
      
      <!-- Amplify button moved to floating position -->

      <div id="youtube-auth-section">
        <div id="youtube-not-connected" class="youtube-connection-status">
          <div class="connect-youtube">
            <button type="button" id="connect-youtube-btn" class="btn btn-youtube btn-large">
              <svg class="btn-icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                <path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
              </svg>
              Connect YouTube Account
            </button>
          </div>
        </div>

        <div id="youtube-connected" class="youtube-connection-status hidden">
          <div class="connected-status">
            <div class="status-icon success">✓</div>
            <span>YouTube account connected</span>
            <button type="button" id="disconnect-youtube-btn" class="btn btn-secondary btn-small">Disconnect</button>
          </div>
          
          <div class="youtube-video-browser">
            <div class="browser-controls">
              <div class="control-group">
                <label for="channel-selector" class="control-label">Channel:</label>
                <select id="channel-selector" class="form-input">
                  <option value="">Select a channel...</option>
                </select>
              </div>
              <div class="control-group">
                <label for="playlist-selector" class="control-label">Playlist:</label>
                <select id="playlist-selector" class="form-input">
                  <option value="">All Videos (No playlist filter)</option>
                </select>
              </div>
            </div>
            
            <div id="error-message" class="error-message hidden"></div>
            
            <div id="video-grid" class="video-selection-grid hidden">
              <div class="selection-controls">
                <span class="selection-count">0 videos selected</span>
                <div class="selection-actions">
                  <button type="button" id="select-all-btn" class="btn btn-secondary btn-small">Select All</button>
                  <button type="button" id="clear-selection-btn" class="btn btn-secondary btn-small">Clear</button>
                </div>
              </div>
              <div class="videos-container" id="videos-container">
                <!-- Video items will be loaded here -->
              </div>

              <div class="load-more-container hidden" id="load-more-container">
                <button type="button" id="load-more-btn" class="btn btn-secondary">Load More Videos</button>
                <div class="video-count-info" id="video-count-info">
                  <span id="loaded-count">0</span> of <span id="total-count">0</span> videos loaded
                </div>
              </div>


            </div>

          </div>
        </div>
      </div>
    </div>

    <!-- Method Divider -->
    <div class="method-divider"></div>

    <!-- URL Input Method -->
    <div class="upload-method url-method">
      <div class="method-header">
        <h1>Import by URL</h1>
        <!-- <p>Paste YouTube video URLs to import and process</p> -->
      </div>
      
      <form id="url-upload-form" class="upload-form">
        <div class="form-group">
          <label for="youtube-urls">Paste YouTube Video URLs</label>
          <textarea 
            id="youtube-urls" 
            name="youtube_urls" 
            placeholder="Enter YouTube video URLs, one per line:
https://www.youtube.com/watch?v=...
https://www.youtube.com/watch?v=..."
            rows="6"
            class="form-textarea"
            required
          ></textarea>
          <div class="form-help">Enter one URL per line. You can paste multiple URLs at once.</div>
        </div>

        <div id="url-error-message" class="error-message hidden"></div>

      </form>
    </div>
  </div>

  <!-- Floating Action Button -->
  <div id="floating-amplify-btn" class="floating-action-button hidden">
    <button type="button" id="import-selected-btn" class="floating-btn throb">
      <div class="floating-btn-icon">⚡</div>
      <div class="floating-btn-content">
        <div class="floating-btn-text">Amplify Videos</div>
        <div class="floating-btn-count" id="floating-btn-count">0 selected</div>
      </div>
    </button>
  </div>

  <!-- Attention-grabbing arrow pointing to the button 
  <div id="attention-arrow" class="attention-arrow debug-visible">
    <div class="click-here-text">CLICK HERE</div>
    <img src="/images/white_arrow-min.png" class="arrow-image" alt="Click here arrow" />
  </div> -->

  <div id="upload-progress" class="upload-progress hidden">
    <div class="progress-container">
      <h4 id="progress-title">Processing Videos...</h4>
      <div class="progress-bar">
        <div class="progress-fill" id="progress-fill"></div>
      </div>
      <p class="progress-message" id="progress-message">Initializing...</p>
      <div id="progress-details" class="progress-details hidden">
        <div class="processing-list" id="processing-list">
          <!-- Processing status for individual videos -->
        </div>
      </div>
    </div>
  </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const urlForm = document.getElementById('url-upload-form');
  const youtubeUrlsTextarea = document.getElementById('youtube-urls');
  const progressDiv = document.getElementById('upload-progress');
  const progressFill = document.getElementById('progress-fill');
  const progressMessage = document.getElementById('progress-message');
  const progressTitle = document.getElementById('progress-title');
  
  // YouTube OAuth Elements
  const connectYouTubeBtn = document.getElementById('connect-youtube-btn');
  const disconnectYouTubeBtn = document.getElementById('disconnect-youtube-btn');
  const youtubeNotConnected = document.getElementById('youtube-not-connected');
  const youtubeConnected = document.getElementById('youtube-connected');
  const channelSelector = document.getElementById('channel-selector');
  const playlistSelector = document.getElementById('playlist-selector');
  const videoGrid = document.getElementById('video-grid');
  const videosContainer = document.getElementById('videos-container');
  const importSelectedBtn = document.getElementById('import-selected-btn');
  const selectAllBtn = document.getElementById('select-all-btn');
  const clearSelectionBtn = document.getElementById('clear-selection-btn');
  const loadMoreBtn = document.getElementById('load-more-btn');
  const loadMoreContainer = document.getElementById('load-more-container');
  const loadedCountEl = document.getElementById('loaded-count');
  const totalCountEl = document.getElementById('total-count');
  const errorMessageEl = document.getElementById('error-message');
  const urlErrorMessageEl = document.getElementById('url-error-message');
  
  // Content Type Selection Elements
  const contentTypesGrid = document.getElementById('content-types-grid');
  const headerSelectionControls = document.getElementById('header-selection-controls');
  const headerSelectionInfo = document.getElementById('header-selection-info');
  const contentTypeError = document.getElementById('content-type-error');
  const selectAllContentBtn = document.getElementById('select-all-content-btn');
  const clearAllContentBtn = document.getElementById('clear-all-content-btn');
  const selectedContentCount = document.getElementById('selected-content-count');
  
  // State
  let selectedVideos = new Set();
  let selectedUrls = new Set();
  let availableVideos = [];
  let subscriptionLimits = null;
  
  // Content Type Selection State
  let availableContentTypes = [];
  let selectedContentTypes = new Set();
  
  // URL Processing Functions
  function processURLInput() {
    const text = youtubeUrlsTextarea.value.trim();

    // Clear existing URLs from selection
    selectedUrls.clear();

    if (!text) {
      updateSelectionUI();
      return;
    }

    const { urls, errors, invalidUrls, duplicates } = parseURLs(text);

    // Check subscription limits before processing
    const currentSelected = selectedVideos.size;
    const maxAllowed = subscriptionLimits ? subscriptionLimits.remainingVideos : Infinity;
    const availableSlots = maxAllowed - currentSelected;

    // Check if user has no available slots (exhausted subscription)
    if (subscriptionLimits && availableSlots <= 0) {
      const tierMessage = subscriptionLimits.tier === 'free'
        ? `You've used your free video (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`
        : `Your video import limit has been reached (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`;

      showUrlError(`${tierMessage} <a href="/subscription/upgrade">Upgrade your plan</a> to import more videos.

Entered URLs cannot be processed due to subscription limits.`);

      // Don't add any URLs
      selectedUrls.clear();
    } else if (subscriptionLimits && urls.length > availableSlots) {
      const droppedCount = urls.length - availableSlots;
      const droppedUrls = urls.slice(availableSlots);

      // Show prominent error message with details
      showUrlError(`⚠️ SUBSCRIPTION LIMIT REACHED

You tried to import ${urls.length} videos, but your plan allows only ${availableSlots} more.

✅ Added: ${availableSlots} videos
❌ Dropped: ${droppedCount} videos

Dropped URLs:
${droppedUrls.map((url, i) => `${availableSlots + i + 1}. ${url}`).join('\n')}

<a href="/subscription/upgrade">Upgrade your plan</a> to import more videos.`);

      // Only add what we can
      urls.slice(0, availableSlots).forEach(url => selectedUrls.add(url));
    } else {
      // Add all valid URLs
      urls.forEach(url => selectedUrls.add(url));
    }

    // Show detailed messages for errors and duplicates
    let hasIssues = errors.length > 0 || duplicates.length > 0;

    if (hasIssues) {
      let messageLines = [];

      // Handle invalid URLs
      if (errors.length > 0) {
        messageLines.push(`<strong>${errors.length} invalid URL(s) found:</strong>`);
        invalidUrls.forEach((url, index) => {
          messageLines.push(`${index + 1}. "${url}"`);
        });
      }

      // Handle duplicates
      if (duplicates.length > 0) {
        if (messageLines.length > 0) messageLines.push(''); // Add spacing
        messageLines.push(`<strong>${duplicates.length} duplicate video(s) removed:</strong>`);
        duplicates.forEach((dup, index) => {
          messageLines.push(`${index + 1}. "${dup.url}" (Video ID: ${dup.videoId})`);
        });
      }

      // Add help text only if there are invalid URLs
      if (errors.length > 0) {
        messageLines.push('');
        messageLines.push('<strong>Valid YouTube URL formats:</strong>');
        messageLines.push('• https://youtube.com/watch?v=VIDEO_ID');
        messageLines.push('• https://youtube.com/live/VIDEO_ID');
        messageLines.push('• https://youtube.com/shorts/VIDEO_ID');
        messageLines.push('• https://youtu.be/VIDEO_ID');
      }

      const errorMessage = messageLines.join('<br>');
      showUrlError(errorMessage);
    } else {
      // Hide error if all URLs are now valid and no duplicates
      hideUrlError();
    }

    updateSelectionUI();
  }
  
  // Initialize - ensure error is hidden on page load
  if (contentTypeError) {
    contentTypeError.classList.add('hidden');
  }

  // Initialize subscription data from server-side
  subscriptionLimits = {
    remainingVideos: {{subscription.remainingVideos}},
    limits: {{{json subscription.limits}}},
    usage: {{{json subscription.usage}}},
    tier: '{{subscription.tier}}'
  };

  // Initialize core functionality first (independent of OAuth)
  loadContentTypes();

  // Initialize YouTube OAuth status (non-blocking)
  checkYouTubeConnection().catch(error => {
    console.warn('YouTube OAuth check failed, but continuing with URL import functionality:', error);
    showDisconnectedState();
  });
  
  // YouTube OAuth Functions
  async function checkYouTubeConnection() {
    try {
      const response = await fetch('/api/youtube/auth/status');
      const result = await response.json();
      
      if (result.success && result.data.connected) {
        showConnectedState(result.data);
      } else {
        showDisconnectedState();
      }
    } catch (error) {
      console.error('Error checking YouTube connection:', error);
      showDisconnectedState();
    }
  }
  
  // Subscription info is now loaded from server-side rendering (see initialization above)
  
  function showConnectedState(connectionData) {
    youtubeNotConnected.classList.add('hidden');
    youtubeConnected.classList.remove('hidden');
    
    // Populate channels
    channelSelector.innerHTML = '<option value="">Select a channel...</option>';
    if (connectionData.channels) {
      connectionData.channels.forEach(channel => {
        const option = document.createElement('option');
        option.value = channel.id;
        option.textContent = channel.name;
        channelSelector.appendChild(option);
      });
    }
  }
  
  function showDisconnectedState() {
    youtubeNotConnected.classList.remove('hidden');
    youtubeConnected.classList.add('hidden');
  }
  
  async function connectYouTube() {
    try {
      const response = await fetch('/api/youtube/auth');
      const result = await response.json();
      
      if (result.success && result.data.authUrl) {
        window.location.href = result.data.authUrl;
      } else {
        throw new Error(result.message || 'Failed to initiate YouTube connection');
      }
    } catch (error) {
      console.error('Error connecting to YouTube:', error);
      showError(error.message || 'Failed to connect to YouTube. Please try again.');
    }
  }
  
  async function disconnectYouTube() {
    try {
      const response = await fetch('/api/youtube/auth/disconnect', {
        method: 'POST'
      });
      const result = await response.json();
      
      if (result.success) {
        showDisconnectedState();
        clearVideoSelection();
      } else {
        throw new Error(result.message || 'Failed to disconnect');
      }
    } catch (error) {
      console.error('Error disconnecting YouTube:', error);
      showError(error.message || 'Failed to disconnect. Please try again.');
    }
  }
  
  // Variables for pagination
  let currentPageToken = null;
  let isLoadingMore = false;
  
  async function loadChannelVideos(loadMore = false) {
    const channelId = channelSelector.value;
    if (!channelId) return;
    
    // Prevent multiple simultaneous loads
    if (isLoadingMore) return;
    isLoadingMore = true;
    
    // Show loading state
    if (loadMore) {
      loadMoreBtn.disabled = true;
      loadMoreBtn.textContent = 'Loading More...';
    } else {
      // Show loading indicator for initial load
      showLoadingState();
    }
    
    try {
      const playlistId = playlistSelector.value;
      let apiUrl = `/api/youtube/channels/${channelId}/videos`;
      
      // If a playlist is selected, load from that playlist instead
      if (playlistId) {
        apiUrl = `/api/youtube/playlists/${playlistId}/videos`;
      }
      
      // Add page token for pagination if loading more
      if (loadMore && currentPageToken) {
        const separator = apiUrl.includes('?') ? '&' : '?';
        apiUrl += `${separator}pageToken=${encodeURIComponent(currentPageToken)}`;
      }
      
      const response = await fetch(apiUrl);
      const result = await response.json();
      
      if (result.success && result.data) {
        const { videos, nextPageToken, totalResults } = result.data;
        
        // Validate that videos is an array
        if (!Array.isArray(videos)) {
          console.error('Invalid videos data received:', videos);
          showError('Error: Invalid video data received from server');
          return;
        }
        
        if (loadMore) {
          // Append new videos to existing ones
          availableVideos = [...availableVideos, ...videos];
          displayVideos(videos, true); // Only display the new videos, append them
        } else {
          // First load - replace all videos and reset pagination
          availableVideos = videos;
          displayVideos(availableVideos, false); // Display all videos, don't append
          videoGrid.classList.remove('hidden');
        }
        
        // Update pagination state
        currentPageToken = nextPageToken;
        
        // Update load more button visibility
        updateLoadMoreButton(nextPageToken, availableVideos.length, totalResults);
        
        // Hide any existing error messages
        hideError();
      } else {
        throw new Error(result.message || 'Failed to load videos');
      }
    } catch (error) {
      console.error('Error loading videos:', error);
      showError(error.message || 'Failed to load videos. Please try again.');
    } finally {
      isLoadingMore = false;
      if (loadMore) {
        loadMoreBtn.disabled = false;
        loadMoreBtn.textContent = 'Load More Videos';
      } else {
        hideLoadingState();
      }
    }
  }
  
  function updateLoadMoreButton(nextPageToken, loadedCount, totalCount) {
    if (nextPageToken) {
      // There are more videos to load
      loadMoreContainer.classList.remove('hidden');
      loadMoreBtn.disabled = false;
    } else {
      // No more videos to load
      loadMoreContainer.classList.add('hidden');
    }
    
    // Update the count display
    loadedCountEl.textContent = loadedCount;
    totalCountEl.textContent = totalCount;
  }
  
  async function loadMoreVideos() {
    await loadChannelVideos(true); // Call with loadMore = true
  }
  
  function showLoadingState() {
    // Show loading indicator in the video grid area
    if (videoGrid.classList.contains('hidden')) {
      videoGrid.classList.remove('hidden');
    }
    videosContainer.innerHTML = '<div class="loading-indicator">Loading videos...</div>';
  }
  
  function hideLoadingState() {
    // Loading state is hidden when videos are displayed or on error
    // The loading indicator is replaced by actual video content
  }
  
  function showError(message) {
    errorMessageEl.innerHTML = message; // Use innerHTML to parse HTML tags in error messages
    errorMessageEl.classList.remove('hidden');
    // Auto-hide after 5 seconds
    setTimeout(() => hideError(), 5000);
  }

  function showPersistentError(message) {
    errorMessageEl.innerHTML = message; // Use innerHTML for HTML formatting
    errorMessageEl.classList.remove('hidden');
    // No auto-hide timeout for persistent errors
  }

  function showUrlError(message) {
    urlErrorMessageEl.innerHTML = message; // Use innerHTML for HTML formatting
    urlErrorMessageEl.classList.remove('hidden');
    // No auto-hide timeout for URL errors
  }

  function hideUrlError() {
    urlErrorMessageEl.classList.add('hidden');
  }

  function hideError() {
    errorMessageEl.classList.add('hidden');
  }
  
  function displayVideos(videos, append = false) {
    // Validate that videos is an array
    if (!Array.isArray(videos)) {
      console.error('displayVideos called with non-array:', videos);
      showError('Error: Invalid video data received');
      return;
    }
    
    if (!append) {
      videosContainer.innerHTML = '';
    }
    
    videos.forEach(video => {
      const videoElement = createVideoElement(video);
      videosContainer.appendChild(videoElement);
    });
    
    updateSelectionUI();
  }
  
  function createVideoElement(video) {
    const div = document.createElement('div');
    div.className = 'video-item';
    div.setAttribute('data-video-id', video.id);
    div.innerHTML = `
      <div class="video-checkbox">
        <input type="checkbox" id="video-${video.id}" data-video-id="${video.id}" />
        <label for="video-${video.id}" class="checkbox-label"></label>
      </div>
      <div class="video-thumbnail">
        <img src="${video.thumbnail}" alt="${video.title}" />
      </div>
      <div class="video-details">
        <h4 class="video-title">${video.title}</h4>
        <p class="video-duration">${formatDuration(video.duration)}</p>
        <p class="video-published">${formatDate(video.publishedAt)}</p>
      </div>
    `;
    
    const checkbox = div.querySelector('input[type="checkbox"]');
    const checkboxLabel = div.querySelector('.checkbox-label');
    
    checkbox.addEventListener('change', handleVideoSelection);
    
    // Make entire video card clickable
    div.addEventListener('click', function(event) {
      // Don't trigger if clicking directly on checkbox or label (they handle themselves)
      if (event.target === checkbox || event.target === checkboxLabel) {
        return;
      }
      
      event.preventDefault();
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    // Also handle label clicks to ensure proper toggling
    checkboxLabel.addEventListener('click', function(event) {
      event.preventDefault();
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    // Add visual feedback for selection state
    checkbox.addEventListener('change', function() {
      if (this.checked) {
        div.classList.add('selected');
      } else {
        div.classList.remove('selected');
      }
    });
    
    return div;
  }
  
  function handleVideoSelection(event) {
    const videoId = event.target.getAttribute('data-video-id');
    const isChecked = event.target.checked;

    if (isChecked) {
      // Check subscription limits BEFORE selection
      const currentTotal = selectedVideos.size + selectedUrls.size;

      // Check subscription limits BEFORE selection with improved messages
      if (subscriptionLimits && subscriptionLimits.remainingVideos === 0) {
        event.preventDefault();
        event.target.checked = false;
        const tierMessage = subscriptionLimits.tier === 'free'
          ? `You've used your free video (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`
          : `Your video import limit has been reached (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`;
        showError(`${tierMessage} <a href="/subscription/upgrade">Upgrade your plan</a> to import more videos.`);
        return;
      }

      if (subscriptionLimits && currentTotal >= subscriptionLimits.remainingVideos) {
        event.preventDefault();
        event.target.checked = false;
        const urlInfo = selectedUrls.size > 0 ? ` (${selectedUrls.size} URL(s) already selected)` : '';
        showError(`You can only import ${subscriptionLimits.remainingVideos} more video(s) with your current ${subscriptionLimits.tier} plan${urlInfo}.`);
        return;
      }
      selectedVideos.add(videoId);
    } else {
      selectedVideos.delete(videoId);
    }

    updateSelectionUI();
  }

  function updateSelectionUI() {
    const selectionCount = document.querySelector('.selection-count');
    const totalSelected = selectedVideos.size + selectedUrls.size;
    const floatingAmplifyBtn = document.getElementById('floating-amplify-btn');
    const floatingBtnCount = document.getElementById('floating-btn-count');

    // Show video grid only when there are YouTube OAuth videos selected
    if (selectedVideos.size > 0) {
      videoGrid?.classList.remove('hidden');
    } else {
      videoGrid?.classList.add('hidden');
    }

    let countText = '';
    if (selectedVideos.size > 0 && selectedUrls.size > 0) {
      countText = `${selectedVideos.size} YouTube video(s) + ${selectedUrls.size} URL(s) selected`;
    } else if (selectedVideos.size > 0) {
      countText = `${selectedVideos.size} YouTube video(s) selected`;
    } else if (selectedUrls.size > 0) {
      countText = `${selectedUrls.size} URL(s) selected`;
    } else {
      countText = '0 videos selected';
    }

    if (selectionCount) {
      selectionCount.textContent = countText;
    }

    // Update floating action button
    if (totalSelected > 0) {
      floatingAmplifyBtn?.classList.remove('hidden');

      // Update count text in floating button
      if (floatingBtnCount) {
        const maxVideos = subscriptionLimits ? subscriptionLimits.remainingVideos : Infinity;
        if (subscriptionLimits && totalSelected >= maxVideos) {
          floatingBtnCount.textContent = `${totalSelected} selected (limit reached)`;
        } else {
          floatingBtnCount.textContent = `${totalSelected} selected`;
        }
      }

      // Add attention-grabbing animations
      const importBtn = document.getElementById('import-selected-btn');
      const attentionArrow = document.getElementById('attention-arrow');

      if (importBtn) {
        importBtn.classList.add('attention-grabbing');
      }

      if (attentionArrow) {
        attentionArrow.classList.add('visible');
      }
    } else {
      floatingAmplifyBtn?.classList.add('hidden');

      // Remove attention-grabbing animations
      const importBtn = document.getElementById('import-selected-btn');
      const attentionArrow = document.getElementById('attention-arrow');

      if (importBtn) {
        importBtn.classList.remove('attention-grabbing');
      }

      if (attentionArrow) {
        attentionArrow.classList.remove('visible');
      }
    }
  }
  
  function selectAllVideos() {
    // Calculate how many videos we can select considering existing URLs
    const currentUrls = selectedUrls.size;
    const maxTotal = subscriptionLimits ? subscriptionLimits.remainingVideos : Infinity;
    const availableSlots = maxTotal - currentUrls;
    const videosToSelect = Math.min(availableVideos.length, Math.max(0, availableSlots));

    selectedVideos.clear();

    if (availableSlots <= 0 && subscriptionLimits) {
      const tierMessage = subscriptionLimits.tier === 'free'
        ? `You've used your free video (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`
        : `Your video import limit has been reached (${subscriptionLimits.usage.videos}/${subscriptionLimits.limits.videos}).`;
      showError(`Cannot select any videos. ${tierMessage} <a href="/subscription/upgrade">Upgrade your plan</a> to import more videos.`);
      updateSelectionUI();
      return;
    }

    for (let i = 0; i < videosToSelect; i++) {
      const video = availableVideos[i];
      selectedVideos.add(video.id);
      const checkbox = document.getElementById(`video-${video.id}`);
      if (checkbox) checkbox.checked = true;
    }

    if (videosToSelect < availableVideos.length && subscriptionLimits) {
      const reason = currentUrls > 0
        ? `Selected ${videosToSelect} of ${availableVideos.length} videos (${currentUrls} URL(s) already selected, ${maxTotal} video limit)`
        : `Selected ${videosToSelect} of ${availableVideos.length} videos due to subscription limits`;
      showError(reason);
    }

    updateSelectionUI();
  }
  
  function clearVideoSelection() {
    selectedVideos.clear();
    selectedUrls.clear();

    const checkboxes = videosContainer.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach(checkbox => checkbox.checked = false);

    // Clear the URL textarea
    if (youtubeUrlsTextarea) {
      youtubeUrlsTextarea.value = '';
    }

    // Hide URL errors when clearing
    hideUrlError();

    updateSelectionUI();
  }
  
  async function importSelectedVideos() {
    const totalSelected = selectedVideos.size + selectedUrls.size;
    if (totalSelected === 0) return;

    // Remove attention-grabbing animations immediately when user clicks
    const importBtn = document.getElementById('import-selected-btn');
    const attentionArrow = document.getElementById('attention-arrow');

    if (importBtn) {
      importBtn.classList.remove('attention-grabbing');
    }

    if (attentionArrow) {
      attentionArrow.classList.remove('visible');
    }

    // Final validation: Check subscription limits for combined total
    if (subscriptionLimits && totalSelected > subscriptionLimits.remainingVideos) {
      const tierInfo = subscriptionLimits.tier === 'free'
        ? `Your free plan allows 1 video total and you've used ${subscriptionLimits.usage.videos}.`
        : `Your ${subscriptionLimits.tier} plan allows ${subscriptionLimits.limits.videos} videos and you've used ${subscriptionLimits.usage.videos}.`;
      showError(`You selected ${totalSelected} video(s) but can only import ${subscriptionLimits.remainingVideos} more. ${tierInfo} <a href="/subscription/upgrade">Upgrade your plan</a> for more videos.`);
      return;
    }

    // Check if content types are selected
    if (selectedContentTypes.size === 0) {
      showError('Please select at least one content type to generate.');
      return;
    }

    const contentTypes = Array.from(selectedContentTypes);
    showProgress('Starting Video Processing...', `Initializing ${totalSelected} video(s) for processing...`);
    importSelectedBtn.disabled = true;

    try {
      // Start processing immediately without waiting for completion
      const processingPromises = [];

      // Process YouTube OAuth selected videos
      if (selectedVideos.size > 0) {
        const videoIds = Array.from(selectedVideos);

        const importPromise = fetch('/api/youtube/videos/import', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            videoIds,
            contentTypes
          })
        }).then(response => {
          if (!response.ok) {
            return response.json().then(err => {
              console.error('YouTube import failed:', err);
              throw new Error(err.message || 'Import failed');
            });
          }
          return response;
        }).catch(error => {
          console.error('YouTube import error:', error);
          showError(`YouTube import failed: ${error.message}`);
          throw error;
        });

        processingPromises.push(importPromise);
      }

      // Process URL-based videos
      if (selectedUrls.size > 0) {
        const urls = Array.from(selectedUrls);
        processingPromises.push(
          fetch('/api/videos/batch', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              urls,
              contentTypes
            })
          })
        );
      }

      // Wait for processing to complete before redirecting
      Promise.all(processingPromises).then(async (responses) => {
        // Process responses
        let createdCount = 0;
        let hasErrors = false;

        for (const response of responses) {
          try {
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                if (result.data?.imported !== undefined) {
                  createdCount += result.data.imported;
                } else if (result.data?.processedVideos) {
                  createdCount += result.data.processedVideos.length;
                } else if (result.data?.summary?.successful) {
                  createdCount += result.data.summary.successful;
                } else {
                  createdCount += 1;
                }
              }
            } else {
              hasErrors = true;
              try {
                const errResult = await response.json();
                console.error('Import response error:', errResult.message || response.statusText);
              } catch (_e) {
                console.error('Import response error:', response.statusText);
              }
            }
          } catch (parseError) {
            console.error('Error parsing import response:', parseError);
            hasErrors = true;
          }
        }

        // Only redirect if no errors
        if (!hasErrors) {
          progressMessage.textContent = 'Redirecting to Video Dashboard...';
          setTimeout(() => {
            window.location.href = `/videos?processing=true&count=${totalSelected}&contentTypes=${contentTypes.join(',')}`;
          }, 1000);
        } else {
          showError('Some videos failed to import. Please check and try again.');
          hideProgress();
          importSelectedBtn.disabled = false;
        }
      }).catch(error => {
        console.error('Import error - NOT redirecting:', error);
        showError(`Import failed: ${error.message}`);
        hideProgress();
        importSelectedBtn.disabled = false;
      });

    } catch (error) {
      console.error('Import error:', error);
      showError(error.message || 'Failed to start video processing. Please try again.');
      hideProgress();
      importSelectedBtn.disabled = false;
    }
  }
  
  
  // Progress Functions
  function showProgress(title, message) {
    progressTitle.textContent = title;
    progressMessage.textContent = message;
    progressDiv.classList.remove('hidden');
  }
  
  function hideProgress() {
    progressDiv.classList.add('hidden');
  }
  
  // Utility Functions
  function formatDuration(seconds) {
    // Handle invalid or missing duration values
    if (!seconds || isNaN(seconds) || seconds <= 0) {
      return 'Duration unknown';
    }
    
    const totalSeconds = Math.floor(seconds);
    const hours = Math.floor(totalSeconds / 3600);
    const minutes = Math.floor((totalSeconds % 3600) / 60);
    const secs = totalSeconds % 60;
    
    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  }
  
  function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString();
  }

  function extractVideoId(url) {
    // Extract YouTube video ID from various URL formats - matches backend patterns
    const patterns = [
      /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([a-zA-Z0-9_-]{11})(?:\S*)?/,
      /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})(?:\S*)?/,
      /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([a-zA-Z0-9_-]{11})(?:\S*)?/,
      /(?:https?:\/\/)?(?:www\.)?youtube\.com\/v\/([a-zA-Z0-9_-]{11})(?:\S*)?/,
      /(?:https?:\/\/)?(?:www\.)?youtube\.com\/live\/([a-zA-Z0-9_-]{11})(?:\S*)?/,  // Support for YouTube live URLs
      /(?:https?:\/\/)?(?:www\.)?youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})(?:\S*)?/  // Support for YouTube Shorts
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return match[1];
      }
    }
    return null;
  }
  
  function parseURLs(text) {
    const lines = text.split('\n').map(line => line.trim()).filter(line => line);
    const urls = [];
    const errors = [];
    const invalidUrls = [];
    const duplicates = [];
    const seenVideoIds = new Set();

    lines.forEach((line, index) => {
      // Enhanced regex to support multiple YouTube URL formats:
      // - youtube.com/watch?v=VIDEO_ID
      // - youtube.com/live/VIDEO_ID
      // - youtube.com/shorts/VIDEO_ID
      // - youtu.be/VIDEO_ID
      // - with or without www.
      // - with additional parameters (like ?feature=shared)
      const youtubeRegex = /^https?:\/\/(www\.)?(youtube\.com\/(watch\?v=|live\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
      if (youtubeRegex.test(line)) {
        const videoId = extractVideoId(line);
        if (videoId) {
          if (seenVideoIds.has(videoId)) {
            // This is a duplicate video ID
            duplicates.push({
              url: line,
              videoId: videoId,
              lineNumber: index + 1
            });
          } else {
            // First time seeing this video ID
            seenVideoIds.add(videoId);
            urls.push(line);
          }
        } else {
          // Valid format but couldn't extract ID (shouldn't happen)
          urls.push(line);
        }
      } else {
        errors.push(`Line ${index + 1}: "${line}" is not a valid YouTube URL`);
        invalidUrls.push(line);
      }
    });

    return { urls, errors, invalidUrls, duplicates };
  }
  
  // Playlist Functions
  async function handleChannelChange() {
    const selectedChannelId = channelSelector.value;

    if (selectedChannelId) {
      // Show playlist selector and load playlists
      playlistSelector.classList.remove('hidden');
      await loadChannelPlaylists(selectedChannelId);

      // Auto-load the first 50 videos from the selected channel
      await loadChannelVideos(false);
    } else {
      // Keep playlist selector visible but reset it
      playlistSelector.innerHTML = '<option value="">All Videos (No playlist filter)</option>';
      videoGrid.classList.add('hidden');

      // Reset state
      currentPageToken = null;
      availableVideos = [];
      selectedVideos.clear();
      updateSelectionUI();
    }
  }
  
  async function loadChannelPlaylists(channelId) {
    try {
      playlistSelector.innerHTML = '<option value="">Loading playlists...</option>';
      
      const response = await fetch(`/api/youtube/channels/${channelId}/playlists`);
      const result = await response.json();
      
      // Reset playlist options
      playlistSelector.innerHTML = '<option value="">All Videos (No playlist filter)</option>';
      
      if (result.success && result.data.playlists) {
        result.data.playlists.forEach(playlist => {
          const option = document.createElement('option');
          option.value = playlist.id;
          option.textContent = `${playlist.title} (${playlist.itemCount || 0} videos)`;
          playlistSelector.appendChild(option);
        });
      }
    } catch (error) {
      console.error('Error loading playlists:', error);
      playlistSelector.innerHTML = '<option value="">All Videos (No playlist filter)</option>';
    }
  }
  
  async function handlePlaylistChange() {
    const selectedChannelId = channelSelector.value;
    
    if (selectedChannelId) {
      // Auto-reload videos when playlist changes
      await loadChannelVideos(false);
    }
  }
  
  // Event Listeners
  connectYouTubeBtn?.addEventListener('click', connectYouTube);
  disconnectYouTubeBtn?.addEventListener('click', disconnectYouTube);
  channelSelector?.addEventListener('change', handleChannelChange);
  playlistSelector?.addEventListener('change', handlePlaylistChange);
  loadMoreBtn?.addEventListener('click', loadMoreVideos);
  importSelectedBtn?.addEventListener('click', importSelectedVideos);
  selectAllBtn?.addEventListener('click', selectAllVideos);
  clearSelectionBtn?.addEventListener('click', clearVideoSelection);
  
  // Add URL processing event listener
  youtubeUrlsTextarea?.addEventListener('input', processURLInput);
  youtubeUrlsTextarea?.addEventListener('paste', function() {
    // Use setTimeout to allow paste content to be processed
    setTimeout(processURLInput, 10);
  });
  
  // Prevent form submission since we use the unified button
  urlForm.addEventListener('submit', (e) => {
    e.preventDefault();
  });

  // Content Type Selection Functions
  async function loadContentTypes() {
    try {
      contentTypeError.classList.add('hidden');

      const response = await fetch('/api/videos/content-types', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      
      if (!result.success || !result.data?.contentTypes) {
        throw new Error(result.message || 'Invalid response format');
      }

      availableContentTypes = result.data.contentTypes;
      renderContentTypes();
      
      // Select all content types by default
      availableContentTypes.forEach(contentType => {
        selectedContentTypes.add(contentType.key);
      });

      // Ensure transcript is always included (redundant but explicit)
      selectedContentTypes.add('transcript_text');
      updateContentSelectionUI();

    } catch (error) {
      console.error('Failed to load content types:', error);
      contentTypeError.classList.remove('hidden');
    }
  }

  function renderContentTypes() {
    if (!availableContentTypes.length) return;

    // Ensure error message is hidden when we successfully render content
    contentTypeError.classList.add('hidden');

    contentTypesGrid.innerHTML = availableContentTypes.map(contentType => {
      const isTranscript = contentType.key === 'transcript_text';

      return `
        <div class="content-type-compact ${isTranscript ? 'transcript-always-enabled' : ''}">
          <label class="content-type-compact-label">
            <input
              type="checkbox"
              id="content-${contentType.key}"
              value="${contentType.key}"
              data-content-type="${contentType.key}"
              checked
              ${isTranscript ? 'disabled title="Transcript is always included - required for AI content generation"' : ''}
            />
            <div class="content-type-compact-content">
              <span class="content-type-compact-icon">${contentType.icon}</span>
              <span class="content-type-compact-text">${contentType.label}</span>
              <span class="content-type-compact-check">✓</span>
            </div>
          </label>
        </div>
      `;
    }).join('');

    // Initialize all labels as checked and add event listeners
    availableContentTypes.forEach(contentType => {
      const checkbox = document.getElementById(`content-${contentType.key}`);
      const label = checkbox?.closest('.content-type-compact-label');

      if (label) {
        label.classList.add('checked');
      }

      if (checkbox && contentType.key !== 'transcript_text') {
        // Only add change listener to non-transcript types
        checkbox.addEventListener('change', function() {
          handleContentTypeChange(contentType.key);
        });
      }
    });

    contentTypesGrid.classList.remove('hidden');
    headerSelectionControls.classList.remove('hidden');
    headerSelectionInfo.classList.remove('hidden');
  }

  function handleContentTypeChange(contentTypeKey) {
    const checkbox = document.getElementById(`content-${contentTypeKey}`);
    const label = checkbox.closest('.content-type-compact-label');
    
    if (checkbox.checked) {
      selectedContentTypes.add(contentTypeKey);
      label.classList.add('checked');
    } else {
      selectedContentTypes.delete(contentTypeKey);
      label.classList.remove('checked');
    }
    
    updateContentSelectionUI();
  }

  function updateContentSelectionUI() {
    selectedContentCount.textContent = selectedContentTypes.size;
  }

  // Content Selection Control Handlers
  selectAllContentBtn.addEventListener('click', function() {
    availableContentTypes.forEach(contentType => {
      selectedContentTypes.add(contentType.key);
      const checkbox = document.getElementById(`content-${contentType.key}`);
      if (checkbox && contentType.key !== 'transcript_text') {
        // Don't change transcript checkbox state - it's disabled
        checkbox.checked = true;
        const label = checkbox.closest('.content-type-compact-label');
        label.classList.add('checked');
      }
    });
    updateContentSelectionUI();
  });

  clearAllContentBtn.addEventListener('click', function() {
    // Clear all except transcript
    selectedContentTypes.clear();
    selectedContentTypes.add('transcript_text'); // Always keep transcript

    availableContentTypes.forEach(contentType => {
      const checkbox = document.getElementById(`content-${contentType.key}`);
      if (checkbox && contentType.key !== 'transcript_text') {
        // Don't change transcript checkbox state - it's disabled and always checked
        checkbox.checked = false;
        const label = checkbox.closest('.content-type-compact-label');
        label.classList.remove('checked');
      }
    });
    updateContentSelectionUI();
  });

  // No longer need global function since we use proper event listeners

});
</script>

{{/layouts/main}}