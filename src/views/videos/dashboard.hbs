{{#> layouts/main}}

<div class="video-dashboard">
  <div class="dashboard-top-row">
    <!-- Left Side: Header and Actions -->
    <div class="dashboard-left">
      <div class="dashboard-header">
        <h1>Video Dashboard</h1>
        <p>Manage your video content and AI-generated insights</p>
        
        {{#if subscription}}
        <div class="subscription-info">
          <span class="tier-badge tier-{{subscription.tier}}">{{capitalize subscription.tier}} Plan</span>
          <span class="usage-info">{{subscription.usage.videos}}/{{subscription.limits.videos}} videos used</span>
        </div>
        {{/if}}
      </div>

      <div class="dashboard-actions">
        {{#if (gt subscription.limits.videos 0)}}
        <a href="/videos/upload" class="btn btn-primary">Amplify Videos</a>
        {{else}}
        <a href="/subscription/upgrade" class="btn btn-primary">Upgrade to Upload Videos</a>
        {{/if}}
        <a href="/videos/library" class="btn btn-secondary">View Library</a>
        {{#if subscription.features.analyticsAccess}}
        <a href="/videos/analytics" class="btn btn-outline">Analytics</a>
        {{/if}}
      </div>
    </div>

    <!-- Right Side: Processing Status Table -->
    <div class="dashboard-right">
      <!-- Video Processing Status Dashboard (shown only when videos are being processed) -->
      <div class="processing-status-container" id="processing-status-container" style="display: none;">
    <div class="status-header">
      <h2>Video Processing Status Dashboard</h2>
      <button class="collapse-btn" id="collapse-status-btn">‚àí</button>
    </div>
    
    <div class="status-content" id="status-content">
      <div class="status-table-container">
        <table class="status-table" id="status-table">
          <thead>
            <tr>
              <th class="video-col">Video</th>
              <th class="content-col" data-tooltip="Transcript extraction">
                <div class="col-header">
                  <span class="col-icon">üìù</span>
                  <span class="col-label">Transcript</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Summary generation">
                <div class="col-header">
                  <span class="col-icon">üìÑ</span>
                  <span class="col-label">Summary</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Study guide creation">
                <div class="col-header">
                  <span class="col-icon">üìö</span>
                  <span class="col-label">Study Guide</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Discussion guide">
                <div class="col-header">
                  <span class="col-icon">üí¨</span>
                  <span class="col-label">Discussion Guide</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Group activities guide">
                <div class="col-header">
                  <span class="col-icon">üë•</span>
                  <span class="col-label">Group Guide</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Social media posts">
                <div class="col-header">
                  <span class="col-icon">üì±</span>
                  <span class="col-label">Social Media Posts</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Quiz questions">
                <div class="col-header">
                  <span class="col-icon">‚ùì</span>
                  <span class="col-label">Quiz</span>
                </div>
              </th>
              <th class="content-col" data-tooltip="Video chapters">
                <div class="col-header">
                  <span class="col-icon">üìñ</span>
                  <span class="col-label">Chapters</span>
                </div>
              </th>
            </tr>
          </thead>
          <tbody id="status-table-body">
            <!-- Dynamic content will be inserted here -->
          </tbody>
        </table>
      </div>
    </div>
  </div>
    </div> <!-- Close dashboard-right -->
  </div> <!-- Close dashboard-top-row -->

  <div class="recent-videos">
    <div class="section-header">
      <h2>Recent Videos</h2>
      <a href="/videos/library" class="view-all-link">View All</a>
    </div>
    
    <div class="video-grid" id="recent-videos-grid">
      <div class="loading-placeholder">Loading recent videos...</div>
    </div>
  </div>
</div>

<script>
// Load Socket.IO and initialize processing status manager when ready
(function() {
  const script = document.createElement('script');
  script.src = '/socket.io/socket.io.js';
  
  script.onload = function() {
    console.log('Socket.IO client loaded successfully');
    initializeProcessingManager();
  };
  
  script.onerror = function() {
    console.warn('Could not load Socket.IO from server, status dashboard will not work');
    // Initialize without Socket.IO (degraded mode)
    initializeProcessingManager();
  };
  
  document.head.appendChild(script);
})();

// Global variable to hold the status manager
let statusManager = null;

function initializeProcessingManager() {
// Processing Status Management
class ProcessingStatusManager {
  constructor() {
    this.socket = null;
    this.processingVideos = new Map();
    this.isCollapsed = false;
    this.init();
  }

  init() {
    // Initialize Socket.IO connection
    this.initSocket();
    
    // Set up UI event listeners
    this.setupUIListeners();
    
    // Check for processing videos on page load
    this.checkForProcessingVideos();
  }

  async initSocket() {
    // Check if io is available
    if (typeof io === 'undefined') {
      console.warn('Socket.IO not loaded, status dashboard will work in degraded mode');
      return;
    }
    
    // Get JWT token from secure endpoint
    const token = await this.getAuthToken();
    
    if (!token) {
      console.warn('No auth token found, cannot connect to status updates');
      return;
    }

    try {
      // Use same origin as the current page
      console.log('üîå Connecting to Socket.IO server on same origin');
      
      this.socket = io({
        auth: { token: token },
        transports: ['websocket', 'polling'] // Try websocket first, fallback to polling
      });
    } catch (error) {
      console.error('Failed to create Socket.IO connection:', error);
      return;
    }

    this.socket.on('connect', () => {
      console.log('‚úÖ Connected to processing status updates');
      console.log('üîÑ Requesting current status...');
      this.socket.emit('request-status');
    });

    this.socket.on('disconnect', () => {
      console.log('‚ùå Disconnected from processing status updates');
    });

    this.socket.on('processing-status-update', (data) => {
      this.handleStatusUpdate(data);
    });

    this.socket.on('processing-status-batch', (videos) => {
      this.handleStatusBatch(videos);
    });

    this.socket.on('connect_error', (error) => {
      console.error('Socket connection error:', error);
    });
  }

  async getAuthToken() {
    try {
      console.log('üîë Requesting auth token from secure endpoint');
      const response = await fetch('/videos/socket-token');
      
      if (response.ok) {
        const data = await response.json();
        console.log('üîë Received auth token from secure endpoint');
        return data.token;
      } else {
        console.error('üîë Failed to get auth token:', response.status);
        return null;
      }
    } catch (error) {
      console.error('üîë Error getting auth token:', error);
      return null;
    }
  }

  setupUIListeners() {
    const collapseBtn = document.getElementById('collapse-status-btn');
    if (collapseBtn) {
      collapseBtn.addEventListener('click', () => {
        this.toggleCollapse();
      });
    }
  }

  toggleCollapse() {
    const content = document.getElementById('status-content');
    const btn = document.getElementById('collapse-status-btn');
    
    this.isCollapsed = !this.isCollapsed;
    
    if (this.isCollapsed) {
      content.style.display = 'none';
      btn.textContent = '+';
    } else {
      content.style.display = 'block';
      btn.textContent = '‚àí';
    }
  }

  checkForProcessingVideos() {
    // Check URL parameters for recently imported videos
    const urlParams = new URLSearchParams(window.location.search);
    const importedVideos = urlParams.get('imported');
    
    if (importedVideos) {
      // Show the processing status dashboard
      this.showProcessingDashboard();
      
      // Clear the imported parameter but keep others
      const newUrl = new URL(window.location);
      newUrl.searchParams.delete('imported');
      window.history.replaceState({}, '', newUrl.toString());
    }
    
    // Also try to connect and request status regardless of URL params
    // This helps show any ongoing processing from previous sessions
    setTimeout(() => {
      if (this.socket && this.socket.connected) {
        this.socket.emit('request-status');
      }
    }, 1000);
  }

  handleStatusUpdate(data) {
    console.log('üì° Received status update:', data);
    const { videoId, status } = data;
    this.processingVideos.set(videoId, status);
    this.updateStatusTable();
    this.showProcessingDashboard();
  }

  handleStatusBatch(videos) {
    console.log('üì¶ Received status batch:', videos.length, 'videos');
    videos.forEach(status => {
      console.log('üìπ Video status:', status.videoId, status);
      this.processingVideos.set(status.videoId, status);
    });
    
    if (videos.length > 0) {
      this.updateStatusTable();
      this.showProcessingDashboard();
    } else {
      console.log('‚ö†Ô∏è No videos in batch to display');
    }
    
    // Refresh completed videos to remove any that are now processing
    if (typeof refreshCompletedVideos === 'function') {
      refreshCompletedVideos();
    }
  }

  showProcessingDashboard() {
    const container = document.getElementById('processing-status-container');
    if (container) {
      container.style.display = 'block';
    }
  }

  hideProcessingDashboard() {
    const container = document.getElementById('processing-status-container');
    if (container) {
      container.style.display = 'none';
    }
  }

  updateStatusTable() {
    console.log('üìä Updating status table...');
    const tbody = document.getElementById('status-table-body');
    if (!tbody) {
      console.error('‚ùå Status table body not found');
      return;
    }

    // Convert map to array and sort by start time
    const videos = Array.from(this.processingVideos.values())
      .sort((a, b) => new Date(b.startTime) - new Date(a.startTime));

    console.log('üìπ Videos to display:', videos.length);
    videos.forEach(video => {
      console.log(`  - ${video.videoTitle} (${video.videoId}): transcript=${video.transcript?.status}, content processing...`);
    });

    if (videos.length === 0) {
      console.log('‚ö†Ô∏è No videos to show, hiding dashboard');
      this.hideProcessingDashboard();
      return;
    }

    tbody.innerHTML = videos.map(video => this.createVideoRow(video)).join('');

    // Auto-hide if all videos are completed
    const hasActiveProcessing = videos.some(video => 
      !video.completed && (
        video.transcript.status === 'pending' ||
        Object.values(video.content).some(content => content.status === 'pending')
      )
    );

    if (!hasActiveProcessing) {
      setTimeout(() => {
        this.hideProcessingDashboard();
        // Refresh completed videos to show newly completed ones
        if (typeof refreshCompletedVideos === 'function') {
          refreshCompletedVideos();
        }
      }, 3000); // Hide after 3 seconds and refresh completed videos
    }
  }

  createVideoRow(video) {
    const contentTypes = ['summary_text', 'study_guide_text', 'discussion_guide_text', 'group_guide_text', 'social_media_text', 'quiz_text', 'chapters_text'];
    
    return `
      <tr data-video-id="${video.videoId}">
        <td class="video-cell">
          <div class="video-title">${this.truncateText(video.videoTitle, 40)}</div>
          <div class="video-time">${this.formatTime(video.startTime)}</div>
        </td>
        <td class="status-cell ${this.getStatusClass(video.transcript.status)}">
          ${this.getStatusIcon(video.transcript.status)}
        </td>
        ${contentTypes.map(type => `
          <td class="status-cell ${this.getStatusClass(video.content[type]?.status)}">
            ${this.getStatusIcon(video.content[type]?.status)}
          </td>
        `).join('')}
      </tr>
    `;
  }

  getStatusClass(status) {
    switch (status) {
      case 'completed': return 'status-completed';
      case 'pending': return 'status-pending';
      case 'failed': return 'status-failed';
      case 'skipped': return 'status-skipped';
      default: return 'status-pending';
    }
  }

  getStatusIcon(status) {
    switch (status) {
      case 'completed': return '<span class="status-icon completed">‚úì</span>';
      case 'pending': return '<span class="status-icon pending">‚è≥</span>';
      case 'failed': return '<span class="status-icon failed">‚úó</span>';
      case 'skipped': return '<span class="status-icon skipped">‚àí</span>';
      default: return '<span class="status-icon pending">‚è≥</span>';
    }
  }

  truncateText(text, maxLength) {
    if (!text) return 'Untitled Video';
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  }

  formatTime(timestamp) {
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
}

// Initialize processing status manager
statusManager = new ProcessingStatusManager();

// Load completed videos and populate processing table after a brief delay
setTimeout(() => {
  loadCompletedVideos();
  populateProcessingTable();
}, 1500);
}

async function loadCompletedVideos() {
  try {
    console.log('üîÑ Loading completed videos...');
    const videosResponse = await fetch('/api/videos?limit=6');
    
    console.log('üì° Response status:', videosResponse.status);
    console.log('üì° Response ok:', videosResponse.ok);
    
    if (!videosResponse.ok) {
      throw new Error(`HTTP ${videosResponse.status}: ${videosResponse.statusText}`);
    }
    
    const videosData = await videosResponse.json();
    console.log('üìπ Videos API Response:', videosData);
    console.log('üìπ Response structure:', {
      success: videosData.success,
      dataExists: !!videosData.data,
      videosExists: !!videosData.data?.videos,
      videosLength: videosData.data?.videos?.length || 0
    });
    
    const gridElement = document.getElementById('recent-videos-grid');
    if (!gridElement) {
      console.warn('Video grid element not found');
      return;
    }
    
    if (videosData.success && videosData.data?.videos?.length > 0) {
      // Filter videos by status: COMPLETED videos show in cards, PENDING videos show in processing table
      let completedVideos = videosData.data.videos.filter(video => {
        // Show only completed videos in cards
        const isCompleted = video.status === 'completed' || video.status === 'processed' || !video.status;
        console.log(`Video ${video.video_title} (${video.videoid}): status=${video.status}, showInCards=${isCompleted}`);
        return isCompleted;
      });
      
      console.log(`üìä Showing ${completedVideos.length} completed videos in cards from ${videosData.data.videos.length} total`);
      
      if (completedVideos.length > 0) {
        gridElement.innerHTML = completedVideos.map(video => `
          <div class="video-card">
            <div class="video-info">
              <h4 class="video-title">${video.video_title || 'Untitled Video'}</h4>
              <p class="video-channel">${video.channel_name || 'Unknown Channel'}</p>
              <div class="video-status status-${video.status || 'completed'}">${video.status || 'Completed'}</div>
            </div>
          </div>
        `).join('');
      } else {
        showEmptyState(gridElement);
      }
    } else {
      console.log('üìπ No videos to display or API error');
      if (!videosData.success) {
        console.error('API returned error:', videosData.message || 'Unknown error');
        gridElement.innerHTML = `<div class="error-state">
          API Error: ${videosData.message || 'Failed to load videos'}
        </div>`;
      } else {
        console.log('üìπ Showing empty state (no videos found)');
        showEmptyState(gridElement);
      }
    }
  } catch (error) {
    console.error('Error loading videos:', error);
    console.error('Error details:', {
      message: error.message,
      stack: error.stack
    });
    
    const gridElement = document.getElementById('recent-videos-grid');
    if (gridElement) {
      gridElement.innerHTML = `<div class="error-state">
        Failed to load videos: ${error.message}
        <br><small>Check console for details</small>
      </div>`;
    }
  }
}

function showEmptyState(gridElement) {
  const videoLimit = {{{subscription.limits.videos}}};
  const uploadAction = videoLimit > 0 
    ? `<a href="/videos/upload" class="btn btn-primary">Upload Video</a>`
    : `<a href="/subscription/upgrade" class="btn btn-primary">Upgrade to Upload Videos</a>`;
    
  gridElement.innerHTML = `
    <div class="empty-state">
      <h3>No videos yet</h3>
      <p>${videoLimit > 0 ? 'Upload your first video to get started.' : 'Upgrade your plan to start uploading videos.'}</p>
      ${uploadAction}
    </div>
  `;
}

// Refresh completed videos when processing status changes
function refreshCompletedVideos() {
  loadCompletedVideos();
}

// Populate processing table with pending videos from API
async function populateProcessingTable() {
  try {
    console.log('üîÑ Loading pending videos for processing table...');
    const videosResponse = await fetch('/api/videos?limit=20'); // Get more videos to find pending ones
    
    if (!videosResponse.ok) {
      throw new Error(`HTTP ${videosResponse.status}: ${videosResponse.statusText}`);
    }
    
    const videosData = await videosResponse.json();
    
    if (videosData.success && videosData.data?.videos?.length > 0) {
      // Find videos that are pending/processing
      const pendingVideos = videosData.data.videos.filter(video => {
        const isPending = video.status === 'pending' || video.status === 'processing' || video.status === 'importing';
        console.log(`Video ${video.video_title} (${video.videoid}): status=${video.status}, isPending=${isPending}`);
        return isPending;
      });
      
      console.log(`üìä Found ${pendingVideos.length} pending videos for processing table`);
      
      if (pendingVideos.length > 0 && statusManager) {
        // Add pending videos to processing status manager
        pendingVideos.forEach(video => {
          const mockStatus = {
            videoId: video.videoid,
            videoRecordId: video.id,
            videoTitle: video.video_title || 'Untitled Video',
            userId: 'current-user',
            startTime: video.created_at || new Date().toISOString(),
            lastUpdate: new Date().toISOString(),
            transcript: { status: 'pending', completedAt: null },
            content: {
              summary_text: { status: 'pending', completedAt: null },
              study_guide_text: { status: 'pending', completedAt: null },
              discussion_guide_text: { status: 'pending', completedAt: null },
              group_guide_text: { status: 'pending', completedAt: null },
              social_media_text: { status: 'pending', completedAt: null },
              quiz_text: { status: 'pending', completedAt: null },
              chapters_text: { status: 'pending', completedAt: null }
            },
            completed: false
          };
          
          statusManager.processingVideos.set(video.videoid, mockStatus);
        });
        
        // Update the processing table
        statusManager.updateStatusTable();
        statusManager.showProcessingDashboard();
        
        // Refresh completed videos to remove any that are now in processing table
        refreshCompletedVideos();
      }
    }
  } catch (error) {
    console.error('Error loading pending videos:', error);
  }
}

</script>

{{/layouts/main}}